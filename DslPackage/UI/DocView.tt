//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

<#@ template inherits="Microsoft.VisualStudio.TextTemplating.VSHost.ModelingTextTransformation" #>
<#@ Dsl processor="DslDirectiveProcessor" requires="fileName='..\..\Dsl\DslDefinition.dsl'" #>
<#@ output extension=".cs" #>
<#
	string dslName = this.Dsl.Name;
	string viewControlTypeName = "ModelViewControl";
#>
#region usings
using DslShell=global::Microsoft.VisualStudio.Modeling.Shell;
#endregion

namespace <#= CodeGenerationUtilities.GetPackageNamespace(this.Dsl) #>
{
	/// <summary>
	/// Partial implementation of the modeling_testDocView class that enables the presentation
	/// of the model in a WinForm control (supporting Data binding and selection pushing).
	/// This partial is independent on the controls implementation.
	/// </summary>
	/// <remarks>		
	/// If you get a compilation error arising from this Class labeled:
	/// The type or namespace 'ModelViewControl' could not be found ...
	/// it is most likely caused by a change in the Winforms control type updated in the UI project.
	/// 
	/// To fix this, you need to change the value of the 'viewControlTypeName' at the 
	/// top of the DocView.tt file generating this DocView.cs file
	///</remarks>
	internal partial class <#= dslName #>DocView
	{
		#region Custom Editor and View setup

		private <#=viewControlTypeName#> windowsFormViewControl;

		/// <summary>
		/// Access to the Windows.Form View control that represents the Model
		/// </summary>
		protected <#=viewControlTypeName#> WindowsFormViewControl
		{
			get
			{
				if (this.windowsFormViewControl == null)
				{
					this.windowsFormViewControl = new <#=viewControlTypeName#>();
				}
				return this.windowsFormViewControl;
			}
		}

		/// <summary>
		/// This DSL defines a custom editor. Therefore, we must have a partial implementation of DocView and
		/// override the Window property of this class to specify the window that will be hosted as the editor.
		/// </summary>
		public override System.Windows.Forms.IWin32Window Window
		{
			get
			{
				return this.WindowsFormViewControl;
			}
		}

		/// <summary>
		/// Set up the View with the Model's data.
		/// </summary>
		/// <returns>true if LoadView was sucessful, false otherwise</returns>
		protected override bool LoadView()
		{
			bool result = base.LoadView();
			if (result)
			{
				global::System.Diagnostics.Debug.Assert(this.DocData.RootElement != null, "View initialized before data available.");
				this.WindowsFormViewControl.DataBind(this.DocData.RootElement);

				// Add all of the currency managers from the form.
				this.SelectionPusher.AddCurrencyManagerProvidersFromContainer(this.WindowsFormViewControl.Components);
			}
			return result;
		}
		#endregion

		#region Selection Management
		private DslShell::CurrentSelectionPusher selectionPusher;

		/// <summary>
		/// Component to push the selected item on the form to the PropertiesWindow
		/// Or more generally to the Visual Studio selection
		/// </summary>
		protected DslShell::CurrentSelectionPusher SelectionPusher
		{
			get
			{
				if (this.selectionPusher == null)
				{
					this.selectionPusher = new DslShell::CurrentSelectionPusher(this.ServiceProvider, this);
				}
				return this.selectionPusher;
			}
		}

		/// <summary>
		/// Implement object selection as a simple collection.
		/// </summary>
		/// <remarks>
		/// Base class has no implementation of this method so we'll need to
		/// provide a simple one.
		/// </remarks>
		protected override void DoSelectObjects(uint count, object[] objects, uint flags)
		{
			//Clear current selection (even if objects array is null/empty)
			base.SelectedElements.Clear();
			if (count > 0 && objects != null && objects.Length > 0)
			{
				for (int i = 0; i < count && i < objects.Length; i++)
				{
					base.SelectedElements.Add(objects[i]);
				}
			}
			this.OnSelectionChanged(null);
		}
		#endregion
	}
}